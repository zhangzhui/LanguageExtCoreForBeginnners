## Snapshot vs Serializable 隔离级别

### Snapshot（快照隔离）
**只检查写入冲突**

```
事务A: 读取 x=10, 读取 y=20, 写入 x=15
事务B: 读取 x=10, 读取 y=20, 写入 y=25
```

两个事务都能成功提交！因为：
- A 只写了 x
- B 只写了 y
- 它们写的变量不冲突

### Serializable（可串行化）
**检查读取+写入冲突**

同样的场景：
```
事务A: 读取 x=10, 读取 y=20, 写入 x=15
事务B: 读取 x=10, 读取 y=20, 写入 y=25
```

**一个事务会失败！** 因为：
- A 读了 y，B 写了 y → 冲突！
- B 读了 x，A 写了 x → 冲突！

---

## 经典例子：Write Skew（写偏斜）

想象一个约束：`x + y >= 30`

初始状态：`x=20, y=20`（满足 40 >= 30）

| 时间 | 事务A | 事务B |
|------|-------|-------|
| T1 | 读 x=20, y=20 | 读 x=20, y=20 |
| T2 | 检查: 20+20-5=35 >= 30 ✓ | 检查: 20+20-5=35 >= 30 ✓ |
| T3 | 写 x=15 | 写 y=15 |
| T4 | 提交 | 提交 |

最终：`x=15, y=15` → `15+15=30`

但如果两个事务各减10呢？

| Snapshot | Serializable |
|----------|--------------|
| 两个都提交 | 一个会回滚 |
| x=10, y=10 (违反约束!) | 保持一致性 |

---

## 简单记忆

| 隔离级别 | 检查什么 | 性能 | 安全性 |
|---------|---------|------|--------|
| **Snapshot** | 我写的东西有没有被别人也写 | 更好 | 够用，但有 write skew |
| **Serializable** | 我读的东西有没有被别人写 | 稍差 | 最强，无任何异常 |

**选择建议**：
- 大多数情况用 `Snapshot` 就够了
- 如果有跨变量的业务约束（如上例），用 `Serializable`

---

## Commute（可交换操作）

`Commute` 是一种优化，用于**可交换的操作**，让它们不冲突。

### 什么是可交换（Commutative）？

操作的顺序不影响最终结果：

```csharp
x + 5 + 10 = x + 10 + 5  // 加法可交换
x * 2 * 3 = x * 3 * 2    // 乘法可交换
list.Add(a); list.Add(b) ≠ list.Add(b); list.Add(a)  // 不可交换（顺序不同）
```

### 普通写法的问题

```csharp
var counter = Ref(0);

// 线程A
atomic(() => counter.Value = counter.Value + 1);

// 线程B
atomic(() => counter.Value = counter.Value + 1);
```

两个都是"读然后写"，会冲突！一个必须重试。

### 用 Commute 优化

```csharp
var counter = Ref(0);

// 线程A
atomic(() => commute(counter, x => x + 1));

// 线程B
atomic(() => commute(counter, x => x + 1));
```

**不会冲突！** 两个都能成功提交。

### 原理

| 普通写法 | Commute |
|---------|---------|
| 提交时检查：我读的值有没有变？ | 提交时：直接在最新值上应用函数 |
| 变了就冲突重试 | 不关心中间变化，反正结果一样 |

Commute 在提交阶段才真正执行：
```
线程A读到0 → 提交时发现是1 → 应用 x+1 → 变成2
线程B读到0 → 提交时发现是2 → 应用 x+1 → 变成3
```

### 适用场景

| 场景 | 用什么 |
|------|--------|
| 计数器 +1 -1 | `commute(ref, x => x + 1)` |
| 累加金额 | `commute(ref, x => x + amount)` |
| 设置具体值 | `ref.Value = 100`（不能用commute） |
| 依赖当前值做判断 | `ref.Value`（不能用commute） |

---

## 重新计算 vs 延迟计算（Commute原理详解）

### 普通写法：重新计算（Retry）

```csharp
atomic(() => {
    var val = counter.Value;   // 1. 读
    // ... 一堆复杂计算 ...     // 2. 算（可能很慢）
    counter.Value = val + 1;   // 3. 写
});
```

冲突时：**整个 atomic 块从头再来**
- 重新读
- 重新算（又跑一遍那堆复杂计算）
- 重新写

### Commute：延迟到提交时计算

```csharp
atomic(() => {
    // ... 其他操作 ...
    commute(counter, x => x + 1);  // 只是"记录"这个意图
});
```

执行过程：
1. `commute` 调用时：**不立即计算**，只记录 "要对 counter 执行 `x => x + 1`"
2. 提交时：拿到 counter 的**最新值**，应用函数

### 对比示例

```
假设 counter 初始 = 0，两个线程同时执行

【普通写法】
线程A: 读0 → 算 → 写1 → 提交成功
线程B: 读0 → 算 → 写1 → 冲突！→ 重新读1 → 重新算 → 写2 → 提交成功
                          ↑
                     整个块重跑

【Commute】
线程A: 记录 x+1 → 提交时：读最新值0 → 算0+1=1 → 写1 → 成功
线程B: 记录 x+1 → 提交时：读最新值1 → 算1+1=2 → 写2 → 成功
                                    ↑
                              只在提交时算一次，不冲突
```

### 关键区别

|  | 普通写法 | Commute |
|--|---------|---------|
| 什么时候算 | atomic 块里算 | 提交时才算 |
| 冲突了怎么办 | 整个块重跑 | 不会冲突 |
| 计算次数 | 可能多次（重试） | 只算一次 |

**Commute 的本质**：把计算延迟到提交那一刻，用最新值算，所以根本不存在"读到旧值"的问题，自然就不会冲突。