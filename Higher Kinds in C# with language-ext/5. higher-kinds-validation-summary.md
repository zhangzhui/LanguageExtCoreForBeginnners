# C# Higher Kinds 系列（第5部分）- Validation 总结

> 原文：Higher Kinds in C# with language-ext [Part 5 - validation] --- `信用卡验证是一个很好的设计函数的例子`

> 作者：Paul Louth

> 发布日期：2024年3月24日

> 原文链接：https://paullouth.com/higher-kinds-in-c-with-language-ext-part-5-validation/

## 概述

本文是 C# Higher Kinds 系列的第5篇，重点介绍了 **Validation** 这一最有用的 Applicative 类型。Validation 允许在计算过程中收集**多个错误**，而不仅仅是第一个错误。

## 核心概念

### 1. Lifted（提升）概念 --- 一般伴随着new操作符

**"Lifted"** 是指将简单值和函数提升到"更高空间"进行操作，只有在有`具体且健壮`的方式时才回到"低层空间"。

- 例如：对于 `Maybe<string>`，只有在有意义的默认值（默认值是 `Nothing` ）时才转换回 `string`
- 否则继续在可选计算中使用 `Map`、`Apply` 等操作

**词源学**：虽然"lifted"的确切词源不清楚，但作者认为这是因为在图表中，提升的元素字面上位于其他元素之上，这也是 higher-kinds 中"higher"的起源。

### 2. Applicative 模式

Applicative 提供了一个标准模式：通过 `Map` 和 `Apply` 的链式调用来组合操作。

```csharp
K<F, B> Apply<A, B>(K<F, Func<A, B>> mf, K<f, A> ma)
```

- `Map` 函数将"低层"函数提升到"lifted"空间
- `Apply` 在 lifted 结构上应用函数
- 对于 `Functor`，使用 `Map`
- 对于 `Maybe`、`List`、`Either` 等，使用 `Apply`

### 3. Pure 函数

`Pure` 函数是 Applicative trait 的一部分，用于将任何值或函数`提升`为"embellished"值和函数。

```csharp
// Pure 和 Map 可以提升任何值
Pure(ch - '0')  // 将字符提升为 Maybe<int> 带可选性
```

## Validation 类型详解

### 核心特性

Validation 是一种特殊的 Applicative 类型，具有以下特点：

1. **收集多个错误**：不像 `Either` 或 `Maybe` 只返回第一个错误，Validation 会收集所有遇到的错误
2. **组合性**：通过 Applicative 的组合能力自动实现错误收集
3. **类似编译器**：产生类似编译器的详细错误输出

### 与 Either 的区别

- **Either/Maybe**：遇到第一个错误就停止
- **Validation**：收集所有错误后再返回

## 实际应用：信用卡验证

文章通过构建一个完整的信用卡验证系统来演示 Validation 的强大功能。

### 数据模型

```csharp
// 信用卡号（16位数字）
public record CardNumber(Seq<int> Number);

// 到期日期（月/年格式）
public record Expiry(int Month, int Year);

// CVV码（3位数字）
public record CVV(int Number);

// 完整的信用卡详情
public record CreditCardDetails(CardNumber CardNumber, Expiry Expiry, CVV CVV)
{
    public static CreditCardDetails Make(CardNumber cardNo, Expiry expiry, CVV cvv)
        => new (cardNo, expiry, cvv);
}
```

### 验证组件

#### 1. 数字验证器

```csharp
static Validation<Error, int> CharToDigit(char ch) =>
    ch is >= '0' and <= '9'
        ? Pure(ch - '0')
        : Fail(Error.New($"expected a digit, but got: {ch}"));
```

**特点**：
- 使用 `Pure` 构造成功情况
- 使用 `Fail` 构造失败情况（返回 `Fail<E>` 类型）

#### 2. 验证所有数字

使用 `Iterable` 的高级功能遍历和验证：

```csharp
static Validation<Error, Iterable<int>> ValidateAllDigits(string value) =>
    value.AsIterable()
         .Traverse(CharToDigit)
         .As();
```

**说明**：
- `Iterable` 是 `IEnumerable` 的增强版本，支持 `Functor`、`Foldable`、`Applicative`、`Monad`、`Semigroup` 和 `Monoid`
- `Traverse` 对每个元素运行转换
- 自动收集多个错误

**测试示例**：
```csharp
ValidateAllDigits("xy123");  // Fail([expected a digit, but got: x, expected a digit, but got: y])
ValidateAllDigits("123");    // Success([1, 2, 3])
```

#### 3. 长度验证器

```csharp
static Validation<Error, K<F, A>> ValidateLength<F, A>(K<F, A> fa, int length)
    where F : Foldable<F>
    => fa.Count() == length
        ? Pure(fa)
        : Fail(Error.New($"expected length to be {length}, but got: {fa.Count()}"));
```

支持任何可折叠类型，使用 `Count()` 扩展方法。

#### 4. 范围验证器

```csharp
static Validation<Error, A> ValidateInRange<A>(A value, Range<A> range)
    where A : IAdditionOperators<A, A, A>, IComparisonOperators<A, A, bool> =>
    range.InRange(value)
        ? Pure(value)
        : Fail(Error.New($"expected value in range of {range.From} to {range.To}, but got: {value}"));
```

### CVV 验证

```csharp
static Validation<Error, CVV> ValidateCVV(string cvv) =>
    Fun<int, string, CVV>((code, _) => new CVV(code))
        .Map(ValidateInt(cvv))
        .Apply(ValidateLength(cvv, 3))
        .As();
```

**组合模式**：
1. 使用 `Fun` 创建构造函数
2. `Map` 提升第一个验证（整数验证）
3. `Apply` 应用第二个验证（长度验证）
4. 自动收集所有错误

**测试结果**：
```csharp
ValidateCVV("xy123");  
// Fail([expected a digit, but got: x, expected a digit, but got: y, expected length to be 3, but got: 5])

ValidateCVV("123");    
// Success(123)
```

### 日期验证

#### Expiry 类型增强

添加了运算符重载以支持日期比较和计算：

```csharp
public record Expiry(int Month, int Year) :
    IAdditionOperators<Expiry, Expiry, Expiry>,
    IComparisonOperators<Expiry, Expiry, bool>
{
    public static readonly Expiry OneMonth = new (1, 0);
    
    public static Expiry operator +(Expiry left, Expiry right)
    {
        var m = left.Month + right.Month;
        var y = left.Year + right.Year;
        while (m > 12)
        {
            m -= 12;
            y++;
        }
        return new Expiry(m, y);
    }
    
    // ... 比较运算符实现
    
    public static Expiry Now => 
        new Expiry(DateTime.Now.Month, DateTime.Now.Year);
    
    public static Range<Expiry> NextTenYears =>
        LanguageExt.Range.fromMinMax(Now, Now + new Expiry(0, 10));
}
```

#### 日期字符串验证

```csharp
static Validation<Error, Expiry> ValidateExpiryDate(string expiryDate) =>
    expiryDate.Split(['\\', '/', '-', ' ']) switch
    {
        [var month, var year] =>
            from my in ValidateInt(month) & ValidateInt(year)
            let exp = new Expiry(my[0], my[1])
            from _ in ValidateInRange(exp, Expiry.NextTenYears)
            select exp,
            
        _ => Fail(Error.New($"expected expiry-date in the format: MM/YYYY, but got: {expiryDate}"))
    };
```

**关键操作**：
- 使用 `&` 运算符组合验证（收集结果到 `Seq`）
- 使用 `|` 运算符在任一成功时继续（但都失败则收集所有错误）

**测试结果**：
```csharp
ValidateExpiryDate("10-2024");  // Success(10/2024)
ValidateExpiryDate("02-2034");  // Success(2/2034)
ValidateExpiryDate("10/2034");  // Fail([expected value in range of 3/2024 to 3/2034, but got: 10/2034])
ValidateExpiryDate("1/2023");   // Fail([expected value in range of 3/2024 to 3/2034, but got: 1/2023])
```

### 信用卡号验证（Luhn 算法）

#### ValidateLuhn 实现

```csharp
static Validation<Error, Seq<int>> ValidateLuhn(Seq<int> digits)
{
    int checkDigit = 0;
    for (int i = digits.Length - 2; i >= 0; --i)
    {
        checkDigit *= ((i % 2) is 0) switch
        {
            true => digits[i] > 4 ? digits[i] * 2 - 9 : digits[i] * 2,
            false => digits[i]
        };
    }
    
    return (10 - checkDigit % 10) % 10 == digits.Last
        ? Pure(digits)
        : Fail(Error.New("invalid card number"));
}
```

这是 [Luhn 算法](https://en.wikipedia.org/wiki/Luhn_algorithm)的实现，用于验证信用卡号的校验和。

#### 完整的信用卡号验证

```csharp
static Validation<Error, CardNumber> ValidateCardNumber(string cardNo) =>
    (ValidateAllDigits(cardNo), ValidateLength(cardNo, 16))
        .Apply((digits, _) => digits.ToSeq())
        .Bind(ValidateLuhn)
        .Map(digits => new CardNumber(digits))
        .As();
```

**测试结果**：
```csharp
ValidateCardNumber("4560005094752584");  // Success([4, 5, 6, 0, 0, 0, 5, 0, 9, 4, 7, 5, 2, 5, 8, 4])
ValidateCardNumber("00000");             // Fail([expected length to be 16, but got: 5])
ValidateCardNumber("0000000000000000x"); // Fail([expected a digit, but got: x, expected length to be 16, but got: 17])
ValidateCardNumber("0000000000000000x"); // Fail([expected a digit, but got: x, expected length to be 16, but got: 17])
```

### 完整验证组合

```csharp
public static Validation<Error, CreditCardDetails> Validate(string cardNo, string expiryDate, string cvv) =>
    fun<CardNumber, Expiry, CVV, CreditCardDetails>(CreditCardDetails.Make)
        .Map(ValidateCardNumber(cardNo))
        .Apply(ValidateExpiryDate(expiryDate))
        .Apply(ValidateCVV(cvv))
        .As();
```

**最终测试**：
```csharp
Validate("4560005094752584", "12-2024", "123");
// Success(CreditCard([4, 5, 6, 0, 0, 0, 5, 0, 9, 4, 7, 5, 2, 5, 8, 4], 12/2024, 123))

Validate("00000", "00-2345", "Wxyz");
// Fail([expected length to be 16, but got: 5, expected value in range of 3/2024 to 3/2034, but got: 00/2345, ...])
```

## 错误处理改进

### MapFail 增强上下文

文章展示了如何使用 `MapFail` 为错误添加更多上下文信息：

```csharp
static Validation<Error, CVV> ValidateCVV(string cvv) =>
    Fun<int, string, CVV>((code, _) => new CVV(code))
        .Map(ValidateInt(cvv).MapFail(_ => Error.New("CVV code should be a number")))
        .Apply(ValidateLength(cvv, 3).MapFail(_ => Error.New("CVV code should be 3 digits")))
        .As();
```

这允许将底层的细粒度错误包装成更友好的高层错误消息。

### 使用 MapFail 构建错误层次

可以创建 `Error` 层次结构，其中内部错误持有更细粒度的错误，而外层错误提供友好的错误信息：

```csharp
static Validation<Error, CardNumber> ValidateCardNumber(string cardNo) =>
    (ValidateAllDigits(cardNo), ValidateLength(cardNo, 16))
        .Apply((digits, _) => digits.ToSeq())
        .Bind(ValidateLuhn)
        .Map(digits => new CardNumber(digits))
        .MapFail(e => Error.New("card number not valid", e)); // 注意参数e，是内部详细的错误信息
```

**测试结果**：
```csharp
Validate("00000", "00-2345", "Wxyz");
// Fail([card number not valid, expected value in range of 3/2024 to 3/2034, but got: 00/2345, ...])
```

## Validation 的 Apply 实现

Validation 的 `Apply` 实现与 Monad 的工作方式相反：

```csharp
static K<Validation<FAIL>, B> Applicative<Validation<FAIL>>.Apply<A, B>(
    K<Validation<FAIL>, Func<A, B>> mf,
    K<Validation<FAIL>, A> ma) =>
    mf switch
    {
        Validation.Success<FAIL, Func<A, B>> (var f) =>
            ma switch
            {
                Validation.Success<FAIL, A> (var s) =>
                    Validation<FAIL, B>.Success(f(a)),
                    
                Validation.Fail<FAIL, A> (var e) =>
                    Validation<FAIL, B>.Fail(e),
                    
                _ =>
                    Validation<FAIL, B>.Fail(FAIL.Empty)
            },
            
        Validation.Fail<FAIL, Func<A, B>> (var e1) =>
            ma switch
            {
                Validation.Fail<FAIL, A> (var e2) =>
                    Validation<FAIL, B>.Fail(e1 + e2),
                    
                _ =>
                    Validation<FAIL, B>.Fail(e1)
            },
            
        _ => Validation<FAIL, B>.Fail(FAIL.Empty)
    };
```

**关键点**：
- 匹配 `Validation.Fail` 的两种情况，使用 `e1 + e2` 组合错误
- Monad 等待两个操作的**成功**结果后才应用值
- Validation 等待两个操作的**失败**结果后才组合它们

## 关键要点

### Validation vs v4/v5 的区别

**注意**：`|` 运算符在 v5 和 v4 中的行为略有不同：
- **v5**：相比 v4，行为略有不同
- **v4**：更接近 `&` 的行为
- 建议：迁移时查找所有 `Validation` 用法并迁移 `|` 到 `&`

### 错误类型要求

Validation 的 `FAIL` 类型可以是任何值，只要它是 `Monoid`：
- 可以使用自定义 Error 类型
- 可以构建层次化的错误结构

### 组合的力量

文章强调了纯函数式组合的强大之处：

> "It's pure all the way down! It's robust and error free all the way down! It's turtles all the way down! These things stick together like Lego – once you've built your core components then they all stack up beautifully."

通过组合小的验证组件（如数字验证器、整数验证器、范围验证器等），可以构建更大的组件（如 `ValidateCardNumber`、`ValidateExpiryDate`、`ValidateCVV`），最终组合成完整的验证系统。

## 总结

本文深入探讨了 Validation 这一强大的 Applicative 类型：

1. **核心优势**：能够收集所有错误而不仅仅是第一个
2. **实际应用**：通过完整的信用卡验证示例展示其实用性
3. **组合性**：通过小组件组合成大系统的函数式编程范式
4. **类型安全**：利用 C# 的类型系统确保验证逻辑的正确性
5. **错误处理**：支持构建层次化、上下文丰富的错误信息

Validation 的组合能力虽然不如 Functors 和 Monads 那么"漂亮"，但其在实际应用中收集多个错误的能力使其成为不可或缺的工具。