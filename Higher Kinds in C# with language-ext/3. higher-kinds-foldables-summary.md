# Higher Kinds in C# with language-ext [Part 3 - Foldables] æ€»ç»“

## æ–‡ç« æ¦‚è§ˆ
- **åŸæ–‡é“¾æ¥**: https://paullouth.com/higher-kinds-in-c-with-language-ext-part-3-foldables/

## ğŸ“Œ æ ¸å¿ƒæ¦‚å¿µ

**Foldableï¼ˆå¯æŠ˜å ç±»å‹ï¼‰** æ˜¯ä¸€ä¸ªé«˜é˜¶ç±»å‹ç±»ï¼ˆHigher-Kinded Type Classï¼‰ï¼Œ`å®ƒå°†èšåˆæ“ä½œä»ç®€å•çš„åˆ—è¡¨ï¼ˆå¦‚ LINQ ä¸­çš„ Aggregateï¼‰æŠ½è±¡åˆ°è®¸å¤šå…¶ä»–ç±»å‹`ã€‚

## ğŸ¯ ä¸»è¦å†…å®¹

### 1. Foldable çš„å®šä¹‰

Foldable æ˜¯**èšåˆå™¨ï¼ˆaggregatorsï¼‰**ï¼Œé€šå¸¸æä¾›ä¸¤ä¸ªæ ¸å¿ƒæ–¹æ³•ï¼š
- **`Fold`**ï¼šç±»ä¼¼ LINQ çš„ `Aggregate`ï¼ˆä»ç¬¬ä¸€é¡¹åˆ°æœ€åä¸€é¡¹çš„èšåˆï¼‰
- **`FoldBack`**ï¼šåå‘èšåˆï¼ˆä»æœ€åä¸€é¡¹åˆ°ç¬¬ä¸€é¡¹ï¼‰

### 2. Fold æ“ä½œçš„å·¥ä½œåŸç†

```csharp
// Fold ç¤ºä¾‹
(((a * s) * b) * c) * ...

// FoldBack ç¤ºä¾‹  
(a * (b * (... * (z * s))))
```

å…¶ä¸­ `*` æ˜¯å ä½ç¬¦æ“ä½œç¬¦ï¼Œè¡¨ç¤ºä¼ é€’ç»™ `Fold` çš„äºŒå…ƒå‡½æ•°ï¼Œ`a, b, c, z` ä»£è¡¨å¯æŠ˜å ç»“æ„ä¸­çš„å€¼ï¼Œ`s` ä»£è¡¨åˆå§‹çŠ¶æ€ã€‚

### 3. Foldable æ¥å£å®šä¹‰

```csharp
public interface Foldable<T>
    where T : Foldable<T>
{
    // æŠ½è±¡æ–¹æ³• - å¿…é¡»å®ç°
    public static abstract S Fold<A, S>(K<T, A> ta, S initial, Func<S, A, S> f);
    
    public static abstract S FoldBack<A, S>(K<T, A> ta, S initial, Func<S, A, S> f);
    
    // è™šæ‹Ÿæ–¹æ³• - æä¾›é»˜è®¤å®ç°
    public static virtual bool IsEmpty<A>(K<T, A> ta) => 
        T.Fold(ta, true, (_, _) => false);
    
    public static virtual int Count<A>(K<T, A> ta) =>
        T.Fold(ta, 0, (s, _) => s + 1);
    
    public static virtual A Sum<A>(K<T, A> ta)
        where A : INumber<A> =>
        T.Fold(ta, A.Zero, (s, x) => s + x);
    
    // ... æ›´å¤šæ–¹æ³•
}
```

### 4. ä¸ºä¸åŒç±»å‹å®ç° Foldable

#### List å®ç°
```csharp
public record List :
    Functor<List>,
    Foldable<List>
{
    public static S Fold<A, S>(K<List, A> xs, S initial, Func<S, A, S> f) =>
        xs.As().Items.Aggregate(initial, f);
    
    public static S FoldBack<A, S>(K<List, A> xs, S initial, Func<S, A, S> f) =>
        xs.As().Items.AsEnumerable().Reverse().Aggregate(initial, f);
}
```

#### Maybe å®ç°
```csharp
public class Maybe :
    Functor<Maybe>,
    Foldable<Maybe>
{
    public static S Fold<A, S>(K<Maybe, A> ma, S initial, Func<S, A, S> f) =>
        ma switch
        {
            Just<A> (var x) => f(initial, x),
            Nothing<A>      => initial
        };
}
```

#### Either å®ç°
```csharp
public class Either<L> :
    Functor<Either<L>>,
    Foldable<Either<L>>
{
    public static S Fold<A, S>(K<Either<L>, A> ma, S initial, Func<S, A, S> f) =>
        ma switch
        {
            Left<L, A>       => initial,
            Right<L, A> (var r) => f(initial, r)
        };
}
```

### 5. Foldable æä¾›çš„ä¸°å¯ŒåŠŸèƒ½

é€šè¿‡å®ç° Foldableï¼Œç±»å‹å¯ä»¥å…è´¹è·å¾—ä»¥ä¸‹æ–¹æ³•ï¼š

- **`Count`** - è®¡ç®—å…ƒç´ æ•°é‡
- **`Sum`** - æ±‚å’Œï¼ˆéœ€è¦ `INumber<A>` çº¦æŸï¼‰
- **`IsEmpty`** - æ£€æŸ¥æ˜¯å¦ä¸ºç©º
- **`All`** / **`Any`** - æ–­è¨€æ£€æŸ¥
- **`Contains`** - æ£€æŸ¥æ˜¯å¦åŒ…å«ç‰¹å®šå€¼
- **`AsEnumerable`** - è½¬æ¢ä¸º `IEnumerable<A>`

ç¤ºä¾‹ï¼š
```csharp
var mx = new Nothing<int>();
var my = new Just<int>(100);
var mz = new List<int>([1, 2, 3, 4, 5]);

var c1 = mx.Count();  // 0
var c2 = my.Count();  // 1
var c3 = mz.Count();  // 5
```

### 6. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

æ–‡ç« å¼ºè°ƒäº†ä¸€ä¸ªé‡è¦çš„è®¾è®¡å†³ç­–ï¼š

**é»˜è®¤å®ç° vs ä¼˜åŒ–å®ç°**
- é»˜è®¤æ–¹æ³•ï¼ˆå¦‚ `IsEmpty`, `Count`ï¼‰éœ€è¦éå†æ•´ä¸ªç»“æ„
- å¯¹äº `List`ï¼Œæˆ‘ä»¬çŸ¥é“æ•°ç»„çš„é•¿åº¦ï¼Œä¸éœ€è¦éå†
- è§£å†³æ–¹æ¡ˆï¼šå°†è¿™äº›æ–¹æ³•ç§»å…¥ Foldable traitï¼Œè®¾ä¸º `static virtual`
- è¿™æ ·å¯ä»¥åœ¨ trait å®ç°ä¸­é‡å†™ä»¥æä¾›ä¼˜åŒ–ç‰ˆæœ¬

**ä¼˜åŒ–åçš„ List å®ç°ï¼š**
```csharp
public static bool IsEmpty<A>(K<List, A> ta) =>
    ta.As().Items.Length == 0;

public static int Count<A>(K<List, A> ta) =>
    ta.As().Items.Length;
```

### 7. æ‰©å±•æ–¹æ³•çš„æ›´æ–°

```csharp
public static class FoldableExtensions
{
    public static S Fold<T, A, S>(this K<T, A> ta, S initial, Func<S, A, S> f)
        where T : Foldable<T> =>
        T.Fold(ta, initial, f);
    
    public static bool IsEmpty<T, A>(this K<T, A> ta)
        where T : Foldable<T> =>
        T.IsEmpty(ta);
    
    // ... æ›´å¤šæ‰©å±•æ–¹æ³•
}
```

## ğŸ’¡ å…³é”®ä¼˜åŠ¿

1. **æŠ½è±¡èƒ½åŠ›**ï¼šä¸ºä»»ä½•å®ç° Foldable çš„ç±»å‹æä¾›ç»Ÿä¸€çš„èšåˆåŠŸèƒ½
2. **ä»£ç å¤ç”¨**ï¼šä¸€æ¬¡ç¼–å†™é€šç”¨å‡½æ•°ï¼Œé€‚ç”¨äºæ‰€æœ‰ Foldable ç±»å‹
3. **æ€§èƒ½çµæ´»æ€§**ï¼šå…è®¸é’ˆå¯¹ç‰¹å®šç±»å‹ä¼˜åŒ–å®ç°ï¼Œè€Œä¸ç‰ºç‰²æŠ½è±¡æ€§
4. **ç±»å‹å®‰å…¨**ï¼šä¿æŒå¼ºç±»å‹æ£€æŸ¥çš„åŒæ—¶æä¾›æ³›å‹åŠŸèƒ½
5. **æ¸è¿›å¼ä¼˜åŒ–**ï¼šå¯ä»¥å…ˆä½¿ç”¨é»˜è®¤å®ç°å¿«é€Ÿå¼€å‘ï¼Œåç»­å†ä¼˜åŒ–æ€§èƒ½

## ğŸ”‘ é‡è¦å¼•ç”¨

> "These methods will be as fast as any handwritten code and yet we can write abstract functions that work with **any** foldables and **any** functors; yet when they're consumed they run the highly optimised trait implementations, not some generic code that has no understanding of the underlying type."

> "The definition of not optimising prematurely."

## ğŸ†š å¯¹æ¯”ï¼šIEnumerable vs Foldable + Traits

**IEnumerable æ–¹å¼çš„é—®é¢˜ï¼š**
- `List<T>` è½¬ä¸º `IEnumerable<T>` åå˜å¾—ä¸é€æ˜
- åªèƒ½é€šè¿‡æšä¸¾å™¨è®¿é—®åº•å±‚ç±»å‹
- æ‰©å±•æ–¹æ³•æ— æ³•äº†è§£åº•å±‚ç±»å‹çš„å…·ä½“ä¿¡æ¯

**Higher-Kinds + Traits æ–¹å¼çš„ä¼˜åŠ¿ï¼š**
- ä¿æŒç±»å‹ä¿¡æ¯çš„é€æ˜æ€§
- å…è®¸é’ˆå¯¹å…·ä½“ç±»å‹è¿›è¡Œä¼˜åŒ–
- åœ¨æ¶ˆè´¹æ—¶è¿è¡Œé«˜åº¦ä¼˜åŒ–çš„ trait å®ç°

## ğŸ“ æ€»ç»“

Foldable å±•ç¤ºäº† language-ext åº“å¦‚ä½•é€šè¿‡é«˜é˜¶ç±»å‹å’Œ traits åœ¨ C# ä¸­å®ç°å‡½æ•°å¼ç¼–ç¨‹æ¨¡å¼ã€‚å®ƒä¸ä»…æä¾›äº†å¼ºå¤§çš„æŠ½è±¡èƒ½åŠ›ï¼Œè¿˜é€šè¿‡ `static virtual` æ–¹æ³•å…è®¸ç±»å‹ç‰¹å®šçš„ä¼˜åŒ–ï¼Œå®ç°äº†æŠ½è±¡æ€§å’Œæ€§èƒ½çš„å®Œç¾å¹³è¡¡ã€‚è¿™ç§è®¾è®¡ç†å¿µä½“ç°äº†"ä¸è¿‡æ—©ä¼˜åŒ–"çš„åŸåˆ™â€”â€”å¯ä»¥å¿«é€Ÿå¼€å‘é€šç”¨ä»£ç ï¼Œç„¶ååœ¨éœ€è¦æ—¶è¿›è¡Œé’ˆå¯¹æ€§ä¼˜åŒ–ã€‚