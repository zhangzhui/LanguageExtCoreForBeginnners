# Higher Kinds in C# with language-ext [Part 2 - functors] 总结

## 文章概览
- **发布日期**: 2024年2月29日
- **主题**: Functors（函子）
- **原文链接**: https://paullouth.com/higher-kinds-in-c-with-language-ext-part-2/
- **系列**: Higher Kinds in C# 第二部分

## 核心内容

### 1. 问题背景
在第一部分中介绍了 `K<F, A>` 类型，但遗留了一个问题：无法使用传统的 traits 技术实现 `Mappable` trait，因为它包含了 bound-value 类型 `A`，这使得无法映射到新的 bound-value 类型 `B`。
```csharp
public interface Mappable<F> 
    where F : Mappable<F>
{
    public static abstract F<B> Select<A, B>(F<A> list, Func<A, B> f);
}
// error: The type parameter 'F' cannot be used with type arguments
// 'F' for 'Functor'
```

### 2. 解决方案：使用 K<F, A>

文章展示了如何使用 language-ext 的新类型 `K<F, A>` 来解决这个问题：

```csharp
public interface Mappable<F>
    where F : Mappable<F>
{
    public static abstract K<F, B> Select<A, B>(K<F, A> list, Func<A, B> f);
}
```

这里的 `F` 作为"锚点"用于参数化任何我们想要的类型，替代了 `A`。

### 3. List 类型的实现

#### 定义 List 数据类型
```csharp
public record List<A>(A[] Items) : K<List, A>;
```

#### 实现 Mappable trait
```csharp
public class List : Mappable<List>
{
    public static K<List, B> Select<A, B>(K<List, A> list, Func<A, B> f) =>
        new List<B>((List<A>)list)
            .Items
            .Select(f)
            .ToArray());
}
```

### 4. 优化：添加扩展方法

为了避免难看的类型转换，添加了一个扩展方法：

```csharp
public static class ListExtensions
{
    public static List<A> As<A>(this K<List, A> ma) =>
        (List<A>)ma;
}
```

简化后的实现：
```csharp
public static K<List, B> Select<A, B>(K<List, A> list, Func<A, B> f) =>
    new List<B>(list.As().Items.Select(f).ToArray());
```

### 5. 通用的 Select 扩展方法

创建了一个"终极扩展方法"，只需编写一次即可用于所有 `Mappable` 类型：

```csharp
public static class MappableExtensions
{
    public static K<F, B> Select<F, A, B>(this K<F, A> fa, Func<A, B> f)
        where F : Mappable<F> =>
        F.Select(fa, f);
}
```

这使得可以像使用 LINQ 一样使用 Select 操作：

```csharp
var list = new List<int>([1, 2, 3]);
var nlist = list.Select(x => x + 1)
                .Select(x => x * 2);
```

### 6. Maybe 类型示例

文章还展示了如何为 `Maybe` 类型实现 `Mappable`：

```csharp
public abstract record Maybe<A> : K<Maybe, A>;
public record Just<A>(A Value) : Maybe<A>;
public record Nothing<A>() : Maybe<A>;

public class Maybe : Mappable<Maybe>
{
    public static K<Maybe, B> Select<A, B>(K<Maybe, A> maybe, Func<A, B> f) =>
        maybe switch
        {
            Just<A> (var x) => new Just<B>(f(x)),
            Nothing<A>      => new Nothing<B>()
        };
}
```

### 7. Functor（函子）的本质

文章指出 `Mappable` 实际上就是 `Functor`，应该被称为 `Map`。将 C# 的定义与 Haskell 的定义进行对比：

**Haskell 中的 Functor：**
```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
```

**对应关系：**
- `Functor f` == `Functor<F>`
- `f a` == `K<F, A>`
- `f b` == `K<F, B>`
- `(a -> b)` == `Func<A, B>`

两者在结构上完全相同！

### 8. 关键优势

#### 类型安全
虽然需要进行向下转型，但由于只能从 `K<List, A>` 派生出一个类型，所以这是类型安全的。如果错误地派生了两个类型，在首次使用时就会失败。

#### 泛型的力量
- 在 language-ext v4 中，作者实现了超过 400 个函数和 1200 个单元测试
- 所有这些都做相同的事情，但适用于不同的类型
- 使用 `K<T, K<F, A>>` 允许单一实现的 `Traverse` 可以适用于每种类型
- 如果你决定编写一个可遍历或应用类型，它会自动与 language-ext 中的遍历和应用类型配合工作

### 9. 实际应用场景

文章强调虽然 `Functor` 看起来是个微不足道的类型，但这种技术为函数式编程提供了超强的能力。通过这种方法，可以实现真正的高阶多态性，为 C# 带来函数式编程的强大特性。

## 总结

这篇文章深入讲解了如何在 C# 中使用 language-ext 库实现 Functors（函子），通过引入 `K<F, A>` 类型解决了 C# 缺乏高阶类型（higher-kinds）的限制。文章展示了：

1. 如何定义和实现 `Mappable`（即 `Functor`）trait
2. 如何为具体类型（如 `List` 和 `Maybe`）实现该 trait
3. 如何使用扩展方法简化使用
4. C# 实现与 Haskell 的 Functor 类型类的对应关系
5. 这种方法的实际价值和可扩展性

文章为理解后续的 Part 3（关于 foldables）奠定了基础。