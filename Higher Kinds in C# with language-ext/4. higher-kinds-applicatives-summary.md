# C# 高阶类型与 language-ext（第4部分 - Applicatives）总结

## 文档信息
- **标题**: Higher Kinds in C# with language-ext [Part 4 - applicatives]
- **作者**: Paul Louth
- **原文链接**: https://paullouth.com/higher-kinds-in-c-with-language-ext-part-4-applicatives/

## 核心概念

### 什么是 Applicative Functor？

**Applicative Functors** 是介于 Functors 和 Monads 之间的"stepping stone"（中间步骤）。虽然在 Haskell 之外不常被讨论，但它们是极其强大的组合工具。

### 主要特点

1. **不太知名但非常强大**: 相比 Functors 和 Monads，Applicatives 较少被讨论，但具有独特的优势
2. **两大用途**（在 language-ext 中）:
   - 启用 **自动并行处理** effectful computations（效果计算）
   - **自动收集** 验证时的多个错误

---

## Functor 回顾

### Map 方法
如果回顾 `Functor`，它有一个 `Map` 方法：
```csharp
K<F, B> Map<A, B>(Func<A, B> f, K<F, A> ma);
```

这将 `Func<A, B>` 转换为 `Func<F<A>, F<B>>`。

这个就看你怎么观察了：

`Func< A, B >` -> `F< A >` -> `F< B >`

考虑下`Currying`化

所以得出上面的结论 `F< A >` -> `F< B >` 其实就是 `Func<F<A>, F<B>>`

### Map 的工作原理
`Map` 接受一元函数参数，但我们有二元函数（如 `+` 和 `*`），如何使它们变成一元的？

**解决方案**: 使用 **柯里化（Currying）**

---

## 柯里化（Currying）

### 示例：二元函数转一元函数

```csharp
// 二元加法函数
static int Add(int x, int y) => x + y;

// 二元乘法函数
static int Multiply(int x, int y) => x * y;

// 柯里化函数
var add = Curry<int, int, int>(Add);        // (int x) => (int y) => x + y
var multiply = Curry<int, int, int>(Multiply); // (int x) => (int y) => x * y
```

### 部分应用（Partial Application）
柯里化创建嵌套 lambda 而不是单个"tuple" lambda，允许`渐进式`地传入值：

```csharp
var add10 = add(10);  // Func<int, int>
var result = add10(20); // 30
```

---

## Map 的局限性

### 问题示例
当尝试用 `Map` 处理 `Maybe<int>` 中的值：

```csharp
var mw = new Just<int>(1);
var mx = new Just<int>(2);
var my = new Just<int>(3);
var mz = new Just<int>(4);

// multiply是一个拥有 2 个参数的函数
// 或者说(curring)是一个拥有一个参数，但是返回一个Func<int,int>的函数
// 所以返回值是Maybe<Func<int, int>>
K<Maybe, Func<int, int>> r1 = mw.Map(multiply);
```

**问题**: 使用 `Map` 进行多次映射会导致嵌套的 `Maybe`：
```csharp
var lhs = mw.Map(multiply).Map(f => mx.Map(f)); // K<Maybe, K<Maybe, int>>
var rhs = my.Map(multiply).Map(f => mz.Map(f)); // K<Maybe, K<Maybe, int>>
var res = lhs.Map(l => l.Map(add).Map(f => rhs.Map(f))));
```

结果类型：`K<Maybe, K<Maybe, K<Maybe, K<Maybe, int>>>>`（四层嵌套！）

我们需要更好的解决方案：**applicative functors**！

---

## Applicative 接口定义

```csharp
public interface Applicative<F> : Functor<F>
    where F : Applicative<F>
{
    public static abstract K<F, A> Pure<A>(A value);
    
    public static abstract K<F, B> Apply<A, B>(
        K<F, Func<A, B>> mf, 
        K<F, A> ma);
}
```

### 关键方法

#### 1. Pure
- 将普通值提升到 applicative 上下文中
- 类似于构造函数的作用（我一直很纳闷为什么没有new

#### 2. Apply
- 签名与 `Map` 类似，但关键区别：函数本身也被**提升**到 `F<...>` 中
- `Func<A, B>` → `K<F, Func<A, B>>`

---

## Apply 的实现

### 对比 Functor 的 Map

**Functor.Map**:
```csharp
K<F, B> Map<A, B>(Func<A, B> f, K<F, A> ma);
```

**Applicative.Apply**:
```csharp
K<F, B> Apply<A, B>(K<F, Func<A, B>> mf, K<F, A> ma);
```

### Maybe 的 Apply 实现

```csharp
public static K<Maybe, B> Apply<A, B>(
    K<Maybe, Func<A, B>> mf, 
    K<Maybe, A> ma) =>
    mf switch
    {
        Just<Func<A, B>> f =>
            ma switch
            {
                Just<A> a => new Just<B>(f(a)),
                Nothing<A> => new Nothing<B>()
            },
        Nothing<Func<A, B>> => new Nothing<B>()
    };
```

**逻辑**: 
- 如果 `mf` 和 `ma` 都是 `Just`，则应用函数并返回 `Just`
- 否则返回 `Nothing`

---

## 解决嵌套问题

### 使用 Apply 的数学表达式

原始表达式（注意这里中间有个`+`）：`1 × 2 + 3 × 4`

如果操作数在 `Maybe` 中：
```csharp
var mw = new Just<int>(1);
var mx = new Just<int>(2);
var my = new Just<int>(3);
var mz = new Just<int>(4);
```

### 第一步：创建柯里化函数（因为multiply接收两个参数）并`提升`
```csharp
K<Maybe, Func<int, int>> r1 = mw.Map(multiply);
```

`r1` 是一个 `Func` 被提升到 `Maybe` 内部，通过部分应用 `multiply` 到 `mw`。

### 第二步：使用 Apply
```csharp
var r = r1.Apply(mx) // K<Maybe, int>，请看上面的实现：只有r1和mx都是Just时才会执行
```

返回 `K<Maybe, int>` 而不是双重嵌套的 maybe！

### 完整表达式
```csharp
var r = multiply.Map(mw).Apply(mx);  // K<Maybe, int>
```

使用 **翻转参数** 的 `Map` 扩展方法可以更流畅地链式调用。--- 一映射(map)，多应用(apply)

---

## Applicative 表达式风格

### 使用 Map 和 Apply 的链式调用

```csharp
var lhs = multiply.Map(mw).Apply(mx);
var rhs = multiply.Map(my).Apply(mz);
var res = add.Map(lhs).Apply(rhs);
```

**优势**: 
- 更简洁，易于阅读
- 没有嵌套问题
- 支持多参数函数的链式调用

---

## 与 Monads 的区别

### Monads（单子）
- **顺序操作**: 只能按顺序获取每个操作数的最终表达式结果
- 首先获取 `w`，然后 `x`，然后 `y`，最后 `z`
- 如果任何失败，立即返回，不处理其余部分

### Applicatives
- **无顺序语义**: 没有顺序处理的语义
- 可以同时访问函数和参数
- 可以并行计算操作数，独立于彼此

### 表达式树示例

数学表达式 `1 × 2 + 3 × 4` 的树形结构：

```
        +
       / \
      ×   ×
     / \ / \
    1  2 3  4
```

**关键优势**: 两个乘法分支完全独立，可以并行计算左侧和右侧，然后再应用加法。

---

## 自动并行处理

### IO 效果类型的 Apply 实现

```csharp
public static IO<B> Apply<A, B>(
    this IO<Func<A, B>> ff, 
    IO<A> fa) =>
    from tf in ff.Fork()
    from ta in fa.Fork()
    from f in tf.Await
    from a in ta.Await
    select f(a);
```

### 工作原理
1. **Fork**: 在函数 IO 和参数 IO 上调用 `Fork`
2. **并行执行**: 两者在并行线程中运行
3. **Await**: 等待两者完成
4. **应用**: 将函数应用于结果

### 实际示例

```csharp
var io1 = liftIO(() => File.ReadAllTextAsync(path1));
var io2 = liftIO(() => File.ReadAllTextAsync(path2));
var io3 = liftIO(() => File.ReadAllTextAsync(path3));

var concat = (string txt1, string txt2, string txt3) => 
    txt1 + txt2 + txt3;

IO<string> res = concat.Map(io1).Apply(io2).Apply(io3);
```

**结果**: 三个 IO 操作并行运行，然后收集结果调用 `concat` 函数。

### 重要注意事项

- 只有 `io1`、`io2` 和 `io3` 被 fork
- `Map` 不会 fork，因为函数已经可用
- language-ext 的 `Map` 和 `Apply` 会自动处理多参数委托的柯里化

---

## 自动错误收集

### 验证场景

Applicatives 在验证场景中非常有用，可以自动收集所有验证错误。

### 示例（虽然文档提到但未详细展开）

文章提到会在 **Part 5 - Validation** 中详细介绍如何使用 applicatives 进行验证并自动收集多个错误。

---

## 实际应用类型

Applicatives 可以用于任何高阶类型，包括：
- `Either`
- `Option`
- `Seq`
- 等等

所有这些类型都具有 `applicative traits`。

---

## 性能注意事项

### IO 的真实实现

文档提到，`IO` 的 `Apply` 实现实际上**更复杂**，因为：
- `IO<A>` 被实现为 DSL（领域特定语言）
- 进行了优化以避免在不需要时使用 `async`
- 使用 `Fork` 而不是 `async`，并使用 `Task` 值和 `Task.WhenAll`

### 理论一致性
尽管实现细节不同，理论是相同的：**IO 并发自动发生在 applicative 的 `Apply` 行为中**。

---

## 总结与评价

### 优势
1. **强大的组合能力**: Applicatives 在正确情况下非常简洁和优雅
2. **自动并行**: 在 C# 中实现 effectful computations 的自动并行处理
3. **错误收集**: 验证场景中自动收集多个错误
4. **代码可读性**: 比嵌套的 monadic 代码更清晰

### 挑战
1. **学习曲线**: 一开始难以理解
2. **使用场景**: 在 C# 中并非总是适用（相比 Haskell）
3. **优雅性权衡**: 需要选择合适的场景使用，以平衡优雅性和实用性

### 最佳实践建议
- **选择合适的战场**: 当需要 applicatives 的独特能力时使用
- **避免过度使用**: 不要仅为了"分层"行为而强制使用
- **结果代码优雅**: 在使用得当时，代码会更优雅


---

## 关键术语对照

| 英文 | 中文 | 说明 |
|------|------|------|
| Applicative Functor | 应用函子 | 介于 `Functor` 和 `Monad` 之间的抽象 |
| Currying | 柯里化 | 将`多参数`函数转换为一系列`单参数`函数 |
| Partial Application | 部分应用 | 固定函数的部分参数，返回新函数 |
| Lifted | 提升 | 将普通值/函数放入某个`上下文`中，一般伴随着`new`操作符的使用 |
| Sequential Operations | 顺序操作 | `Monads` 的特点 |
| Parallel Processing | 并行处理 | `Applicatives` 的优势 |
| Error Collection | 错误收集 | 验证场景的应用 |

---

## 代码示例总结

### 1. 基本 Applicative 使用
```csharp
// 使用 Map 和 Apply 链式调用
var result = multiply.Map(mw).Apply(mx);
```

### 2. 数学表达式
```csharp
var lhs = multiply.Map(mw).Apply(mx);
var rhs = multiply.Map(my).Apply(mz);  
var res = add.Map(lhs).Apply(rhs);
```

### 3. IO 并行处理 --- 一映射(map)多应用(apply)
```csharp
IO<string> res = concat.Map(io1).Apply(io2).Apply(io3);
```

---

## 总结

Applicative Functors 是函数式编程中的强大工具，虽然学习曲线较陡，但在正确的场景下（特别是需要并行处理或错误收集时）能够提供简洁、优雅且高效的解决方案。language-ext 库将这些概念引入 C#，使得 C# 开发者也能利用这些高级抽象。