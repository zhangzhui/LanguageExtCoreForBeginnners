# C# 中的高阶类型 - Part 6: Traversables (可遍历类型) 总结

## 文章信息
- **标题**: Higher Kinds in C# with language-ext [Part 6 - traversables]
- **作者**: Paul Louth
- **发布日期**: 2024年4月16日
- **原文链接**: https://paullouth.com/higher-kinds-in-csharp-part6-traversables/

## 核心概念

### 什么是 Traversable？是一个特征

**Traversable（可遍历类型）** 结合了 **Applicative** 和 **Foldable** 的能力，允许对抽象结构进行复杂处理。

- **类似 Foldable**：可以遍历结构中的多个元素并聚合
- **和Foldable的关键区别**：Traversable 不暴露聚合状态值，而是返回一个嵌套的 applicative / foldable 结构
- **"flipped"效果**：内部变成外部，外部变成内部

### 详细解释下

- **对比Foldable**：fold让你提供累加器和折叠函数，你能看见并控制聚合状态，最终得到一个裸值（如int）。
- **traversable不暴露聚合状态**： 你不需要提供累加器，只提供一个A -> F< B >的映射函数，聚合逻辑由F类型的applicative行为自行决定
- **traversable返回嵌套结构**： 结果不是裸值，而是F < T< B>>例如（Option<Seq < int>>）,外层是applicative，内层是foldable，两个高阶类型嵌套
- **`核心思想`**： Traversable 把"怎么聚合"的控制权从调用者手中交给了 applicative 类型本身的默认行为（Option 会短路、Validation 会收集错误、IO 可能并行），调用者只需关心每个元素的转换。


## 实际示例

### 基础示例：解析字符串到整数

```csharp
var items = Seq("1", "2", "3", "4", "5");
var values = items.Map(s => parseInt(s));
```

使用 `Map` 的结果：
```csharp
[Some(1), Some(2), Some(3), Some(4), Some(5)]
```

如果有失败项：
```csharp
var items = Seq("1", "2", "3", "X", "5");
var values = items2.Map(s => parseInt(s));
// 结果: [Some(1), Some(2), Some(3), None, Some(5)]
```

**问题**：需要`逐项`检查每个值是否存在。

### 使用 Traverse 的解决方案

这里需要注意下上面的`核心思想`，返回值结果取决于parseInt返回什么样子的applicative，本例中返回Option，所以结果会`短路`。

```csharp
var items = Seq("1", "2", "3", "4", "5");
var values = items.Traverse(s => parseInt(s));
```

输出：
```csharp
Some([1, 2, 3, 4, 5])
```

**类型翻转的魔力**：
- 原本：`Seq<Option<int>>` 
- 翻转后：`Option<Seq<int>>`
- `Option` 外层用于累积内部 foldable（`Seq`），使得 `Option` 嵌入到序列的每个项目中

### 早期退出机制，取决于上面的`核心思想`

如果有任何项失败，整体都会失败：
```csharp
var items = Seq("1", "2", "3", "X", "5");
var values = items.Traverse(s => parseInt(s));
// 结果: None  // Option<Seq<int>>
```

## Traversable 的强大之处

### 与 IO Monad 结合使用，根据上面的`核心思想`，这里可以并行

```csharp
var items = Seq("c:\\test1.txt", "c:\\test2.txt", "c:\\test3.txt");
var values = items.Traverse(File<Runtime>.readAllText);
```

这将并行读取所有文件。如果任何文件读取失败，整个操作失败。

---
### 与 Validation 类型结合，根据上面的`核心思想`，这里可以收集错误

Applicative 类型（如 `Validation`）会收集所有错误，而 `Traverse` 调用会确保如果有很多错误，应该清楚地收集所有失败，而不是继续解析列表的其余部分。

## Trait 定义

### Haskell 定义

```haskell
class (Functor t, Foldable t) => Traversable t where
    traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
```

### C# 定义

```csharp
public interface Traversable<T> : Functor<T>, Foldable<T>
    where T : Traversable<T>, Functor<T>, Foldable<T>
{
    public static abstract K<F, K<T, B>> Traverse<F, A, B>(
        Func<A, K<F, B>> f,
        K<T, A> ta)
        where F : Applicative<F>;
}
```

**约束条件**：
- `(Functor t, Foldable t)` 等同于 `: Functor<T>, Foldable<T>`
- `Applicative f =>` 等同于 `where F : Applicative<F>`

**函数签名**：
- `(a -> f b)` 等同于 `Func<A, K<F, B>>`
- `t a` 等同于 `K<T, A>`
- `f (t b)` 等同于 `K<F, K<T, B>>`

---

## 实现细节

### 两个高阶类型

返回类型是两个嵌套的高阶类型：
- `F` 被约束为 `applicative`- functor
- `T` 被约束为 functor 和 `foldable`

### Seq 的实现

```csharp
static K<F, K<Seq, B>> Traverse<F, A, B>(Func<A, K<F, B>> f, K<Seq, A> ta)
{
    return F.Map<Seq<B>, K<Seq, B>>(
        ks => ks,
        Foldable.foldBack(cons, F.Pure(empty<B>()), ta));
        
    K<F, Seq<B>> cons(K<F, Seq<B>> xs, A x) =>
        Applicative.lift(Prelude.Cons, f(x), xs);
}
```

#### 签名解读

| 部分 | 含义 |
|---|---|
| `K<Seq, A> ta` | 输入：一个 `Seq<A>` 序列（用高阶类型编码表示） |
| `Func<A, K<F, B>> f` | 转换函数：把每个 `A` 转换为一个"包在 applicative `F` 里的 `B`" |
| `K<F, K<Seq, B>>` | 返回：**类型翻转**后的结果 —— `F<Seq<B>>`（外层是 applicative，内层是序列） |

对应 Haskell 签名：`traverse :: Applicative f => (a -> f b) -> t a -> f (t b)`

#### 逐步拆解函数体

**第 1 层：整体结构**

```csharp
return F.Map<Seq<B>, K<Seq, B>>(
    ks => ks,                                              // ②
    Foldable.foldBack(cons, F.Pure(empty<B>()), ta));      // ①
```

执行顺序是 **先 ①，再 ②**。

---

**① 核心：`Foldable.foldBack(cons, F.Pure(empty<B>()), ta)`**

这是一个**从右往左的折叠**，相当于 Haskell 的 `foldr`：

```
foldBack(折叠函数, 初始累加器, 被折叠的序列)
```

- **初始累加器**：`F.Pure(empty<B>())`
  - `empty<B>()` = 空的 `Seq<B>`
  - `F.Pure(...)` = 把空序列"提升"到 applicative `F` 中
  - 类型：`K<F, Seq<B>>`
  - 例：如果 `F` 是 `Option`，则为 `Some(Seq.Empty)`

- **被折叠的序列**：`ta`，即输入的 `K<Seq, A>`

- **折叠函数**：`cons`（见下方）

---

**① 的折叠函数 `cons`**

```csharp
K<F, Seq<B>> cons(K<F, Seq<B>> xs, A x) =>
    Applicative.lift(Prelude.Cons, f(x), xs);
```

每次折叠处理一个元素 `x`：

1. **`f(x)`** — 对当前元素应用转换函数，得到 `K<F, B>`（如 `Option<int>`） --- 最外层跟下面`一致`，在同一个lift空间内
2. **`xs`** — 已折叠的累积结果，类型 `K<F, Seq<B>>`（如 `Option<Seq<int>>`） --- 最外层跟上面`一致`，在同一个lift空间内
3. **`Applicative.lift(Prelude.Cons, f(x), xs)`** — 使用 applicative 的 `lift` 把 `Cons` 函数"提升"到 `F` 上下文中执行

`Prelude.Cons` 的语义是：`(B head, Seq<B> tail) => head :: tail`（把一个元素插到序列头部）

`Applicative.lift` 等价于 Haskell 的 `liftA2`：
```
liftA2 Cons (f x) xs
```

**关键**：这里的聚合行为完全由 `F` 的 applicative 实例决定：
- 如果 `F = Option`：任何一个 `f(x)` 返回 `None`，整个结果短路为 `None`
- 如果 `F = Validation`：所有错误会被收集
- 如果 `F = IO`：可能并行执行

---

**② 外层 `F.Map`**

```csharp
F.Map<Seq<B>, K<Seq, B>>(ks => ks, ...)
```

折叠的结果类型是 `K<F, Seq<B>>`，但方法签名要求返回 `K<F, K<Seq, B>>`。

这一步做的是**类型适配**：把 `F` 内部的 `Seq<B>`（具体类型）映射为 `K<Seq, B>`（高阶类型编码）。

`ks => ks` 是一个恒等函数——值没有变化，只是利用了 C# 的隐式转换（`Seq<B>` 实现了 `K<Seq, B>`），完成了类型层面的"包装"。

#### 执行流程图

```
ta: K<Seq, A> = [a₁, a₂, a₃]
         ↓
foldBack 从右向左折叠
         ↓
初始累加器: F.Pure(empty) = F<[]>
         ↓
处理 a₃: lift(Cons, f(a₃), F<[]>) → F<[b₃]>
         ↓
处理 a₂: lift(Cons, f(a₂), F<[b₃]>) → F<[b₂, b₃]>
         ↓
处理 a₁: lift(Cons, f(a₁), F<[b₂, b₃]>) → F<[b₁, b₂, b₃]>
         ↓
F.Map 类型适配 → F<K<Seq, B>>
         ↓
返回: K<F, K<Seq, B>>
```

#### 具体例子

假设 `F = Option`，输入 `Seq("1", "2", "3")`，`f = parseInt`：

```
foldBack 从右到左：
  1. cons(Some([]),  "3") = lift(Cons, Some(3), Some([])) = Some([3])
  2. cons(Some([3]), "2") = lift(Cons, Some(2), Some([3])) = Some([2, 3])
  3. cons(Some([2,3]), "1") = lift(Cons, Some(1), Some([2,3])) = Some([1, 2, 3])

F.Map 类型适配 → Some([1, 2, 3]) : K<Option, K<Seq, int>>
```

如果输入 `Seq("1", "X", "3")`：
```
foldBack 从右到左：
  1. cons(Some([]),  "3") = lift(Cons, Some(3), Some([])) = Some([3])
  2. cons(Some([3]), "X") = lift(Cons, None, Some([3]))   = None  ← 短路！
  3. cons(None, "1")      = lift(Cons, Some(1), None)     = None

最终结果：None
```

#### 总结

这段代码用 **foldBack + applicative lift** 的组合实现了 Traversable 的`核心`语义：

1. **从右向左折叠**序列，保持元素顺序
2. 对每个元素调用 `f` 产生 applicative 效果
3. 用 `Applicative.lift(Cons, ...)` 在 applicative `上下文`(lift空间)中逐个拼接结果
4. 最终通过 `F.Map` 做类型`适配`，满足高阶类型编码的签名要求

**精髓在于**：调用者只提供 `A → F<B>` 的转换，而"如何聚合"完全由 `F` 的 applicative 行为决定——Option 短路、Validation 收集错误、IO 可并行。

### Either 示例

```csharp
static K<F, K<Either<L>, B>> Traverse<F, A, B>(Func<A, K<F, B>> f, K<Either<L>, A> ta)
{
    ta switch
    {
        Either.Right<L, A> r => F.Map(Right, f(r)),
        Either.Left<L, A> (var l) => F.Pure(Left<B>(l)),
        _ => throw new NotSupportedException()
    };
}
```

**模式匹配**：
- `Either.Right` 情况：调用转换函数 `f`，得到 `F` applicative，然后 `Map` 值到 `Right` 构造函数
- `Either.Left` 情况：不调用转换函数，直接将 `Left` 状态提升到 applicative（使用 `F.Pure`）

## Sequence 方法

在 language-ext v5 中，`Traversable` trait 包含三个额外的默认实现方法：

```csharp
public static virtual K<F, K<T, A>> Sequence<F, A>(
    K<T, K<F, A>> ta)
    where F : Applicative<F> =>
    Traversable.traverse(x => x, ta);

public static virtual K<M, K<T, B>> TraverseM<M, A, B>(
    Func<A, K<M, B>> f,
    K<T, A> ta)
    where M : Monad<M> =>
    Traversable.traverseM(f, ta);

public static virtual K<F, K<T, A>> SequenceM<F, A>(
    K<T, K<F, A>> ta)
    where F : Monad<F> =>
    Traversable.traverseM(x => x, ta);
```

- `Sequence` 和 `SequenceM` 功能相等，一个约束为 `Applicative`，另一个约束为 `Monad`
- `TraverseM` 是 `Traverse` 的 monad 等价物

### 性能优化

对于集合类型（如 `Seq<A>`），实现了 `TraverseM`，因为它强制顺序操作：
- `TraverseM` 强制串行求值而非并行 applicative 行为
- 对于异步类型很有用，因为 applicative 类型的映射通常不会缩短操作（可能运行并行）
- `Seq<A>` 也有 `TraverseM` 实现

## 使用场景

### 最佳实践

在遍历集合类型（如 `Seq<A>`）时：
- **Applicative 类型映射通常不是集合类型**
- 一次性对外部 `Applicative` 执行 `Map` 操作比对每个项都执行更高效

示例：
```csharp
var xs = Seq(Some(1), Some(2), None);
var ys = xs.Sequence();          // 等同于
var zs = xs.Traverse(x => x);    // 使用恒等函数
```

## 转换回具体类型

### 挑战

`Traverse` 扩展方法返回两个嵌套的 `K` 类型。要转换回具体类型需要调用 `.As()` 扩展：

```csharp
public static partial class TraversableExtensions
{
    public static K<F, K<T, B>> Traverse<T, F, A, B>(
        this K<T, A> ta,
        Func<A, K<F, B>> f)
        where T : Traversable<T>
        where F : Applicative<F> =>
        Traversable.traverse(f, ta);
}
```

### 为数据类型添加扩展方法

**Traverse 和 TraverseM 的实现示例**（针对 `Seq<A>`）：

```csharp
public readonly struct Seq<A>
{
    ...
    public K<F, Seq<B>> Traverse<F, B>(Func<A, K<F, B>> f)
        where F : Applicative<F> =>
        F.Map(x => x.As(), Traversable.traverse(f, this));
        
    public K<M, Seq<B>> TraverseM<M, B>(Func<A, K<M, B>> f)
        where M : Monad<M> =>
        M.Map(x => x.As(), Traversable.traverseM(f, this));
}
```

**简化使用**：
```csharp
var items = Seq("1", "2", "3", "4", "5");
Option<Seq<int>> values = items.Traverse(s => parseInt(s)).As();
```

## v4 到 v5 的重大变更

### 移除的方法

- 之前存在的约 500 个扩展方法（`Sequence` 和 `Traverse`）已被移除
- Trait 实现中的方法接管了这些功能
- 类型签名略有不同，移除了一个 `Sequence` 变体

### 使用建议

- **优先使用 `Traverse`** 而不是 `Sequence`
- C# 的类型系统在大多数情况下不能很好地处理嵌套类型
- `Sequence` 在内部嵌套类型已经是 `K<F, A>` 形式时有用

### 嵌套类型限制

**重要提示**：`Sequence` 和 `SequenceM` 接受已经嵌套的类型，但 C# 无法很好地处理：
- 不能在 `Sequence` 中使用 `Seq<Option<int>>`（编译时错误）
- 只能使用 `K<Seq, K<Option, int>>`

**解决方案**：使用 `Traverse` 配合恒等函数：
```csharp
xs.Traverse(x => x)  // 等同于 Sequence，但可以工作
```

### TraverseSerial 和 TraverseParallel

在 v5 之前的 language-ext 中，`Traverse` 扩展方法适用于固定嵌套类型对。现在：
- `TraverseSerial` 和 `TraverseParallel` 已被弃用
- 并行化操作现在取决于 `Traverse` 的实现

## 性能考虑

尽管存在一些粗糙边缘（C# 类型系统的限制），这个版本修复了 `Traverse` 和 `Sequence` 中的 bug，并将其转换为真正通用的 traversable 系统。

## 结论

### 优势

Traverse 是纯函数式编程工具包中**最强大的工具之一**：
- 类型翻转和注入默认 applicative 行为使得转换极其简洁
- 特别适用于序列值处理
- 不仅限于序列！

### 局限性

由于 C# 类型系统的限制，存在一些粗糙边缘：
- 嵌套类型和隐式方差转换的问题
- `Sequence` 相关的一些限制令人沮丧

### v5 改进

尽管存在限制，v5 版本：
- 修复了 `Traverse` 和 `Sequence` 中的 bug
- **因为 trait 系统，而不是尽管有它**
- 现在可以构建**自己的** traversable 类型，可以立即与所有 foldable 和 applicative 类型配合使用

### 作者感悟

过去在应用领域中创建类型时，想要使用 `Traverse`，却发现没有通用的 traversable trait，不得不为该类型实现 `Traverse` 和 `Sequence` n 次以获得与 language-ext 类型相同的功能。这个问题现已解决——只需为类型实现一次 `Traverse` 即可。

### 强大之处

> 当你记住 `Traverse` 是纯函数式编程工具包中最强大的工具之一时——这意味着（不管粗糙边缘）我们在这里获得了一些真正的 FP 超能力。这些超能力最终可以落地到你的代码库中，而不仅仅是 language-ext 提供的类型。

---

## 关键要点

1. **Traversable = Applicative + Foldable**：结合了两者的能力
2. **类型翻转**：`Seq<Option<int>>` → `Option<Seq<int>>`
3. **早期退出**：任何失败都会导致整体失败
4. **强大且简洁**：使复杂的转换变得优雅
5. **与其他类型配合**：Validation、IO、Either 等
6. **优先使用 Traverse**：比 Sequence 更灵活
7. **v5 改进**：通过 trait 系统实现真正的泛型
8. **可扩展**：可以为自定义类型实现 Traversable

## 实用建议

- 在处理可能失败的集合转换时使用 `Traverse`
- 需要并行处理时注意 `Traverse` vs `TraverseM` 的选择
- 利用类型翻转来简化错误处理
- 为自定义领域类型实现 Traversable trait 以获得 FP 超能力