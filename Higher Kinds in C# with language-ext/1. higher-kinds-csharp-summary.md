# Higher Kinds in C# with language-ext [Part 1] - 文章总结

> 原文链接: https://paullouth.com/higher-kinds-in-c-with-language-ext/

> 发布日期: 2024年2月27日

## 文章概述

这篇文章介绍了 language-ext 版本 5 中引入的**高阶类型（Higher-Kinded Types）**概念，这是该库有史以来最重大的更新之一。作者 Paul Louth 详细阐述了为什么 C# 需要高阶类型，以及 language-ext v5 如何通过创新的方式解决这个问题。

## 核心概念详解

### 1. 静态接口成员（Static Interface Members）

C# 的最新特性允许在接口中定义静态抽象成员，这为实现类似函数式编程语言中的 traits 打开了大门。

**示例代码:**
```csharp
public interface Addable<SELF> where SELF : Addable<SELF>
{
    public static abstract SELF Add(SELF x, SELF y);
}
```

**关键点:**
- `Add` 方法是 `static abstract`
- 接口有一个约束，强制 `SELF` 必须继承 `Addable<SELF>`
- 这意味着这个 trait 不能独立存在（必须被类型实现）

### 2. 从 Traits 到 Monoids

文章展示了如何将简单的 `Addable` trait 重构为函数式编程中的核心抽象概念：

#### Semigroup（半群）
```csharp
public interface Semigroup<A>
    where A : Semigroup<A>
{
    public static abstract A operator+(A x, A y);
}
```
- 定义了关联二元操作（加法运算符）
- 执行"加法"（实际上是任何关联二元操作）

#### Monoid（幺半群）
```csharp
public interface Monoid<A> : Semigroup<A>
    where A : Monoid<A>
{
    public static abstract A Empty { get; }
}
```
- 继承自 Semigroup
- 添加了单位元素（`Empty`）

**重要变化:** 在 language-ext v5 中，Semigroup 和 Monoid 现在是类型必须继承的 traits，而不是可选的接口。这允许创建更通用的函数，如 `FoldMap` 和 `Concat`。

### 3. 高阶类型的必要性

#### 问题陈述
C# 面临的核心挑战：
- 无法让不属于自己的类型（如 `string`、`int`）实现 monoid
- 缺乏 ad-hoc 多态性
- 类型参数 `A` 被固定在返回类型中，限制了通用性

```csharp
interface IAdd<TList, A>
{
    public TList<A> Add(TList<A> a, TList<B> b);
}
// error: The type parameter 'TList' cannot be used with type arguments
```

#### 示例问题
尝试创建通用的 `Select` 函数（类似 LINQ）时会遇到问题：

```csharp
// 尝试但失败的方案
public interface Mappable<SELF, A>
    where SELF : Mappable<SELF, A>
{
    public static abstract SELF Select<A, B>(SELF list, Func<A, B> f);
}
```

```csharp
public record MyList<X>(X[] values) : 
    Mappable<MyList<X>>
{
    public static MyList<X> Select<A, B>(MyList<X> list, Func<A, B> f) => 
        // Can't map an X to an A
}
```

**问题:** 无法从数组中提取 `X` 并转换为 `A` 来传递给映射函数 `f`。

### 4. 什么是高阶类型（Higher Kinds）？

**定义:**
- **低阶类型（Lower-Kinded Type）**: `Option<int>` - 完全具体的类型
- **高阶类型（Higher-Kinded Type）**: `Option<A>` - 有一个类型参数 `A` 可以用来构造新类型（如 `Option<int>`、`Option<string>` 等）

**类比:** 将类型想象成函数
- 函数接受一个参数（类型）并返回结果（另一个类型）
- 这是泛型的基础

#### C# 的局限
C# 已经具备泛型能力，但缺少的是**参数化原则的泛化**：
- ✅ 可以：让 `A` 成为 `Option<A>` 中的参数
- ❌ 不可以：让 `Option` 本身成为参数（如 `F<A>`）

**作者的观点:**
> "如果我们能让 `A` 在 `Option<A>` 中成为参数，为什么不能让 `Option` 部分也参数化为 `F<A>`？C# 不允许这样做，但这确实很需要！"

```csharp
// 这个例子解释了上面内容
interface IAdd<TList, A>
{
    public TList<A> Add(TList<A> a, TList<B> b);
}
// error: The type parameter 'TList' cannot be used with type arguments
```

### 5. Magic Functions（魔法函数）的问题

C# 编译器对某些方法名有特殊处理：
- `Select`, `SelectMany`, `Where`, `Join`
- `GroupJoin`, `GetEnumerator`, `GetAwaiter`, `Add`

**存在的问题:**

1. **缺乏可发现性（Discoverability）**
   - 这些是编译器的黑客手段
   - 将高阶类型的 traits 带入 C#，但没有完成繁重的工作

2. **持续需求**
   - 每次 C# 团队需要高阶类型时，就会添加新的魔法函数
   - 开发者只能等待，无法自己实现

**作者评论:**
> "每次 C# 团队需要高阶类型时，他们就黑掉编译器，让我们其余人等待。我觉得这真的很糟糕，因为很明显有需求，但他们不愿意解决。"

### 6. K<F, A> - 革命性的新类型

这是 language-ext v5 中**最重要的新类型**：

```csharp
public interface K<F, A>;
```

**虽然它没有任何成员，但它的重要性体现在:**

#### 🎯 三大核心优势

1. **大规模代码简化**
   - 移除了 30 万行生成和手写的代码
   - 这些代码之前用于模拟通用 traits

2. **赋能开发者**
   - 用户可以编写自己的 functors、applicatives、traversables、foldables、monads 和 monad-transformers
   - 所有这些都获得为这些 trait 实现编写的默认行为

3. **实现真正的高阶类型**
   - 更高级别的多态性
   - Higher-rank polymorphism - higher kinds

#### 工作原理

`K<F, A>` 充当了高阶类型的"包装器"或"标记接口"：
- `F` 代表类型构造器（如 `Option`、`List` 等）
- `A` 代表具体类型参数
- 通过这个接口，可以在 C# 类型系统中模拟高阶类型

### 7. 实际应用场景

文章提到可以使用这个技术来解决之前无法解决的问题，例如：

- 创建适用于所有 `Addable` 类型的通用函数
- 实现适用于任意 monad 的通用组合器
- 编写一次代码，适用于所有容器类型（List、Option、Either 等）

## 关键要点总结

| 概念 | 说明 |
|------|------|
| **静态接口成员** | C# 新特性，允许在接口中定义静态抽象方法 |
| **Semigroup/Monoid** | 函数式编程的基础抽象，v5 中变为必须继承的类型 |
| **高阶类型缺失** | C# 无法将类型构造器（如 `Option`）本身参数化 |
| **Magic Functions** | C# 的临时解决方案，缺乏可发现性和扩展性 |
| **K<F, A>** | language-ext v5 的核心创新，模拟高阶类型 |
| **影响** | 移除 30 万行代码，赋能开发者，实现真正的函数式编程 |

## 设计哲学

作者强调了一个重要的设计决策：

> "这个决策是从 language-ext 早期版本的 ad-hoc 多态方法的重大转变。我相信这是务实的决定，能带来更优雅的代码。稍微不那么优雅的部分是使用不属于你的类型，但我觉得这个权衡是正确的。"

## 适合读者

这篇文章适合：
- C# 开发者，特别是对函数式编程感兴趣的
- language-ext 库的用户
- 想要理解类型系统高级概念的程序员
- 对泛型编程和高阶抽象感兴趣的开发者

## 参考资源

- [language-ext GitHub](https://github.com/louthy/language-ext)
