# 函数式编程核心抽象

## 核心接口（Type Classes）

函数式编程通过`组合少量基础抽象`来表达所有计算模式。这些核心接口形成一个层次结构：

```
Functor           -- 能被映射 (Map)
   ↓
Applicative       -- 能组合独立计算 (Apply + Pure)
   ↓
Monad             -- 能链式依赖计算 (Bind/FlatMap + Pure)
```

再加上几个处理特定场景的：

| 接口 | 核心操作 | 解决什么问题 |
|------|----------|--------------|
| **Functor** | `Map(f)` | 转换容器内的值 |
| **Applicative** | `Apply` + `Pure` | 组合多个独立计算 |
| **Monad** | `Bind/FlatMap` + `Pure` | 链式依赖计算（前一步的结果决定下一步）|
| **Foldable** | `Fold` | 聚合/遍历 |
| **Traversable** | `Traverse` | 带副作用的遍历 |
| **Monoid** | `Empty` + `Combine` | 合并同类型的值 |

## 设计哲学

### 1. 组合优于继承
- 不是定义无数具体类型，而是定义少量行为契约
- 任何类型只要实现这些契约，就能免费获得大量组合能力

### 2. 数学基础 = 普适性
这些接口来自范畴论，它们描述的是**计算的本质结构**：
- `Map` = 保持结构的变换
- `Bind` = 顺序依赖
- `Fold` = 归约

### 3. 少即是多
```
Option, Either, List, Task, IO, Reader, State, Writer...
```
这些看似不同的类型，都只是 Functor/Monad 的不同实例。一套操作，处理所有场景。

## 如何记忆

### 问题导向记忆法

```
我想...                        用什么？
─────────────────────────────────────────
转换容器里的值？               → Functor (Map)
组合多个独立的值？             → Applicative (Apply)
前一步结果决定下一步？         → Monad (Bind)
把多个值合并成一个？           → Monoid (Combine)
遍历并收集结果？               → Traversable (Traverse)
```

### 类比记忆法

| 概念 | 类比 |
|------|------|
| Functor | 管道（数据流过，被转换）|
| Monad | 铁轨（可以分岔，取决于之前的结果）|
| Monoid | 乐高积木（同类型可拼接）|

## 为什么"够用"？

因为这几个接口捕获了计算的**基本模式**：

1. **顺序** → Monad
2. **并行/独立** → Applicative
3. **转换** → Functor
4. **聚合** → Foldable/Monoid
5. **副作用隔离** → IO/Task (也是 Monad)

任何程序都是这些基本模式的组合。就像所有物质由少数基本粒子组成，所有计算由少数基本抽象组成。

## 一句话总结

> 函数式编程找到了计算的"元素周期表"——用最少的基础抽象，通过组合表达最多的可能性。
